// Code generated by go generate; DO NOT EDIT.
// This file was generated from "pagination/generator/pageables_generator.go" at
// 2020-08-20 22:50:46.144537 -0500 CDT m=+0.003146146
// using types listed in "pagination/generator/pageables.yml"

package pagination

import (
	b64 "encoding/base64"
	"errors"

	"github.com/well-informed/wellinformed/graph/model"
)

func BuildInteractionPage(first int, after *string, list []*model.Interaction) (*model.InteractionConnection, error) {
	edges := __Interaction__nodesToEdges(__Interaction__listToNodes(list))
	if after != nil {
		for i := 0; i < len(edges); i++ {
			if *after == edges[i].Cursor {
				nextIdx := i + 1
				if nextIdx == len(edges) {
					return nil, errors.New("cursor not found in list")
				} else if nextIdx+first > len(edges) {
					edges = edges[nextIdx:]
				} else {
					edges = edges[nextIdx : nextIdx+first]
				}
				break
			}
		}
	} else if first < len(edges) {
		edges = edges[:first]
	}
	info := &model.InteractionPageInfo{
		HasPreviousPage: len(edges) > 0 && after != nil,
		HasNextPage:     len(edges) > first,
		StartCursor:     edges[0].Cursor,
		EndCursor:       edges[len(edges)-1].Cursor,
	}
	return &model.InteractionConnection{
		Edges:    edges,
		PageInfo: info,
	}, nil
}

func __Interaction__nodesToEdges(nodes []*model.InteractionNode) []*model.InteractionEdge {
	edges := make([]*model.InteractionEdge, 0)
	for _, node := range nodes {
		edges = append(edges, &model.InteractionEdge{
			Node:   node,
			Cursor: b64.StdEncoding.EncodeToString([]byte(string(node.ID))),
		})
	}
	return edges
}

func __Interaction__listToNodes(list []*model.Interaction) []*model.InteractionNode {
	nodes := make([]*model.InteractionNode, 0)
	for _, item := range list {
		nodes = append(nodes, &model.InteractionNode{
			Value: item,
			ID:    item.ID,
		})
	}
	return nodes
}

func BuildContentItemPage(first int, after *string, list []*model.ContentItem) (*model.ContentItemConnection, error) {
	edges := __ContentItem__nodesToEdges(__ContentItem__listToNodes(list))
	if after != nil {
		for i := 0; i < len(edges); i++ {
			if *after == edges[i].Cursor {
				nextIdx := i + 1
				if nextIdx == len(edges) {
					return nil, errors.New("cursor not found in list")
				} else if nextIdx+first > len(edges) {
					edges = edges[nextIdx:]
				} else {
					edges = edges[nextIdx : nextIdx+first]
				}
				break
			}
		}
	} else if first < len(edges) {
		edges = edges[:first]
	}
	info := &model.ContentItemPageInfo{
		HasPreviousPage: len(edges) > 0 && after != nil,
		HasNextPage:     len(edges) > first,
		StartCursor:     edges[0].Cursor,
		EndCursor:       edges[len(edges)-1].Cursor,
	}
	return &model.ContentItemConnection{
		Edges:    edges,
		PageInfo: info,
	}, nil
}

func __ContentItem__nodesToEdges(nodes []*model.ContentItemNode) []*model.ContentItemEdge {
	edges := make([]*model.ContentItemEdge, 0)
	for _, node := range nodes {
		edges = append(edges, &model.ContentItemEdge{
			Node:   node,
			Cursor: b64.StdEncoding.EncodeToString([]byte(string(node.ID))),
		})
	}
	return edges
}

func __ContentItem__listToNodes(list []*model.ContentItem) []*model.ContentItemNode {
	nodes := make([]*model.ContentItemNode, 0)
	for _, item := range list {
		nodes = append(nodes, &model.ContentItemNode{
			Value: item,
			ID:    item.ID,
		})
	}
	return nodes
}

func BuildSrcRSSFeedPage(first int, after *string, list []*model.SrcRSSFeed) (*model.SrcRSSFeedConnection, error) {
	edges := __SrcRSSFeed__nodesToEdges(__SrcRSSFeed__listToNodes(list))
	if after != nil {
		for i := 0; i < len(edges); i++ {
			if *after == edges[i].Cursor {
				nextIdx := i + 1
				if nextIdx == len(edges) {
					return nil, errors.New("cursor not found in list")
				} else if nextIdx+first > len(edges) {
					edges = edges[nextIdx:]
				} else {
					edges = edges[nextIdx : nextIdx+first]
				}
				break
			}
		}
	} else if first < len(edges) {
		edges = edges[:first]
	}
	info := &model.SrcRSSFeedPageInfo{
		HasPreviousPage: len(edges) > 0 && after != nil,
		HasNextPage:     len(edges) > first,
		StartCursor:     edges[0].Cursor,
		EndCursor:       edges[len(edges)-1].Cursor,
	}
	return &model.SrcRSSFeedConnection{
		Edges:    edges,
		PageInfo: info,
	}, nil
}

func __SrcRSSFeed__nodesToEdges(nodes []*model.SrcRSSFeedNode) []*model.SrcRSSFeedEdge {
	edges := make([]*model.SrcRSSFeedEdge, 0)
	for _, node := range nodes {
		edges = append(edges, &model.SrcRSSFeedEdge{
			Node:   node,
			Cursor: b64.StdEncoding.EncodeToString([]byte(string(node.ID))),
		})
	}
	return edges
}

func __SrcRSSFeed__listToNodes(list []*model.SrcRSSFeed) []*model.SrcRSSFeedNode {
	nodes := make([]*model.SrcRSSFeedNode, 0)
	for _, item := range list {
		nodes = append(nodes, &model.SrcRSSFeedNode{
			Value: item,
			ID:    item.ID,
		})
	}
	return nodes
}

func BuildUserSubscriptionPage(first int, after *string, list []*model.UserSubscription) (*model.UserSubscriptionConnection, error) {
	edges := __UserSubscription__nodesToEdges(__UserSubscription__listToNodes(list))
	if after != nil {
		for i := 0; i < len(edges); i++ {
			if *after == edges[i].Cursor {
				nextIdx := i + 1
				if nextIdx == len(edges) {
					return nil, errors.New("cursor not found in list")
				} else if nextIdx+first > len(edges) {
					edges = edges[nextIdx:]
				} else {
					edges = edges[nextIdx : nextIdx+first]
				}
				break
			}
		}
	} else if first < len(edges) {
		edges = edges[:first]
	}
	info := &model.UserSubscriptionPageInfo{
		HasPreviousPage: len(edges) > 0 && after != nil,
		HasNextPage:     len(edges) > first,
		StartCursor:     edges[0].Cursor,
		EndCursor:       edges[len(edges)-1].Cursor,
	}
	return &model.UserSubscriptionConnection{
		Edges:    edges,
		PageInfo: info,
	}, nil
}

func __UserSubscription__nodesToEdges(nodes []*model.UserSubscriptionNode) []*model.UserSubscriptionEdge {
	edges := make([]*model.UserSubscriptionEdge, 0)
	for _, node := range nodes {
		edges = append(edges, &model.UserSubscriptionEdge{
			Node:   node,
			Cursor: b64.StdEncoding.EncodeToString([]byte(string(node.ID))),
		})
	}
	return edges
}

func __UserSubscription__listToNodes(list []*model.UserSubscription) []*model.UserSubscriptionNode {
	nodes := make([]*model.UserSubscriptionNode, 0)
	for _, item := range list {
		nodes = append(nodes, &model.UserSubscriptionNode{
			Value: item,
			ID:    item.ID,
		})
	}
	return nodes
}

