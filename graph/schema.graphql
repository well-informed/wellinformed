scalar Time

type AuthToken {
  accessToken: String!
  expiredAt: Time!
}

type AuthResponse {
  authToken: AuthToken!
  user: User!
}

type SrcRSSFeed {
  id: ID!
  title: String!
  description: String
  link: String!
  feedLink: String!
  updated: Time!
  lastFetchedAt: Time!
  language: String
  generator: String
  contentItems(input: ContentItemConnectionInput): ContentItemConnection!
  isSubscribed: Boolean!
}

input ContentItemInteractionsInput {
  userID: ID
}

type ContentItem {
  id: ID!
  sourceID: ID!
  sourceTitle: String!
  sourceLink: String!
  title: String!
  description: String!
  content: String!
  link: String!
  updated: Time
  published: Time
  author: String
  guid: String
  imageTitle: String
  imageURL: String
  sourceType: String!
  interaction(input: ContentItemInteractionsInput): Interaction
}

type UserSubscription {
  id: ID!
  user: User!
  srcRSSFeed: SrcRSSFeed!
  createdAt: Time!
}

type UserFeed {
  userID: ID!
  name: String!
  contentItems: [ContentItem!]!
}

type User {
  id: ID!
  firstname: String!
  lastname: String!
  username: String!
  email: String!
  password: String!
  feed: UserFeed!
  srcRSSFeeds(input: SrcRSSFeedConnectionInput): SrcRSSFeedConnection!
  preferenceSets: [PreferenceSet!]!
  activePreferenceSet: PreferenceSet!
  createdAt: Time!
  updatedAt: Time!
  subscriptions(input: UserSubscriptionConnectionInput): UserSubscriptionConnection!
  interactions(readState: ReadState, input: InteractionConnectionInput!): InteractionConnection!
}

type PreferenceSet {
  id: ID!
  user: User!
  name: String!
  active: Boolean!
  sort: sortType!
  startDate: Time
  endDate: Time
}

input PreferenceSetInput {
  name: String!
  """
  true sets the entered preference set as active, false never has any effect.
  A prefSet can only become inactive if another prefSet is set to active
  """
  activate: Boolean!
  sort: sortType!
  startDate: Time
  endDate: Time
}

enum sortType {
  chronological
  sourceName
}

type Interaction {
  id: ID!
  user: User!
  contentItem: ContentItem!
  """
  deprecated in favor of completed and savedForLater bools
  """
  readState: ReadState!
  completed: Boolean!
  savedForLater: Boolean!
  percentRead: Float!
  createdAt: Time!
  updatedAt: Time!
}

enum ReadState {
  completed
  savedForLater
  partiallyRead
  unread
}

input InteractionInput {
  contentItemID: ID!
  readState: ReadState!
  completed: Boolean
  savedForLater: Boolean
  percentRead: Float
}

input SrcRSSFeedInput {
  id: ID
  link: String
  feedLink: String
}

input RegisterInput {
  username: String!
  email: String!
  password: String!
  confirmPassword: String!
  firstname: String!
  lastname: String!
}

input LoginInput {
  email: String!
  password: String!
}

input GetUserInput {
  userID: ID
  email: String
  username: String
}

# Pageable Interface for ContentItem
input ContentItemConnectionInput {
  first: Int!
  after: String
}
type ContentItemConnection {
  edges: [ContentItemEdge!]!
  pageInfo: ContentItemPageInfo!
}
type ContentItemPageInfo {
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: String!
  endCursor: String!
}
type ContentItemEdge {
  node: ContentItem!
  cursor: String!
}

# Pageable Interface for UserSubscription
input UserSubscriptionConnectionInput {
  first: Int!
  after: String
}
type UserSubscriptionConnection {
  edges: [UserSubscriptionEdge!]!
  pageInfo: UserSubscriptionPageInfo!
}
type UserSubscriptionPageInfo {
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: String!
  endCursor: String!
}
type UserSubscriptionEdge {
  node: UserSubscription!
  cursor: String!
}

# Pageable Interface for SrcRSSFeed
input SrcRSSFeedConnectionInput {
  first: Int!
  after: String
}
type SrcRSSFeedConnection {
  edges: [SrcRSSFeedEdge!]!
  pageInfo: SrcRSSFeedPageInfo!
}
type SrcRSSFeedPageInfo {
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: String!
  endCursor: String!
}
type SrcRSSFeedEdge {
  node: SrcRSSFeed!
  cursor: String!
}

# Pageable Interface for Interactions
input InteractionConnectionInput {
  first: Int!
  after: String
}
type InteractionConnection {
  edges: [InteractionEdge!]!
  pageInfo: InteractionPageInfo!
}
type InteractionPageInfo {
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: String!
  endCursor: String!
}
type InteractionEdge {
  node: Interaction!
  cursor: String!
}

type Query {
  srcRSSFeed(input: SrcRSSFeedInput): SrcRSSFeed!
  sources(input: SrcRSSFeedConnectionInput): SrcRSSFeedConnection!
  userFeed: UserFeed!
  me: User!
  user(input: GetUserInput): User!
  getContentItem(input: ID!): ContentItem!
  getInteractionByContentID(input: ID!): Interaction
  preferenceSets: [PreferenceSet!]!
}

type DeleteResponse {
  ok: Boolean!
}

type Mutation {
  addSrcRSSFeed(feedLink: String!): SrcRSSFeed!
  deleteSubscription(srcRSSFeedID: ID!): DeleteResponse!
  register(input: RegisterInput!): AuthResponse!
  login(input: LoginInput!): AuthResponse!
  saveInteraction(input: InteractionInput): ContentItem!
  savePreferenceSet(input: PreferenceSetInput!): PreferenceSet!
}
