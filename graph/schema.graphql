scalar Time

type AuthToken {
  accessToken: String!
  expiredAt: Time!
}

type AuthResponse {
  authToken: AuthToken!
  user: User!
}

type SrcRSSFeed {
  id: ID!
  title: String!
  description: String
  link: String!
  feedLink: String!
  updated: Time!
  lastFetchedAt: Time!
  language: String
  generator: String
  contentItems(input: ConnectionInput): Connection!
  isSubscribed: Boolean!
}

input ContentItemInteractionsInput {
  userID: ID
}

type ContentItem {
  id: ID!
  sourceID: ID!
  sourceTitle: String!
  sourceLink: String!
  title: String!
  description: String!
  content: String!
  link: String!
  updated: Time
  published: Time
  author: String
  guid: String
  imageTitle: String
  imageURL: String
  sourceType: String!
  interaction(input: ContentItemInteractionsInput): Interaction
}

type UserSubscription {
  id: ID!
  user: User!
  srcRSSFeed: SrcRSSFeed!
  createdAt: Time!
}

type UserFeed {
  userID: ID!
  name: String!
  # contentItems(input: ConnectionInput): Connection!
  contentItems: [ContentItem!]!
}

input ConnectionInput {
  first: Int!
  after: String

}
type Connection {
  edges: [Edge!]!
  pageInfo: PageInfo!
}

type PageInfo {
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: String!
  endCursor: String!
}

type Edge {
  node: Node!
  cursor: String!
}

type Node {
  value: Pageable!
  id: ID!
}

union Pageable = Interaction | SrcRSSFeed | UserSubscription | ContentItem

type User {
  id: ID!
  firstname: String!
  lastname: String!
  username: String!
  email: String!
  password: String!
  feed: UserFeed!
  srcRSSFeeds(input: ConnectionInput): Connection!
  preferenceSets: [PreferenceSet!]!
  activePreferenceSet: PreferenceSet!
  createdAt: Time!
  updatedAt: Time!
  # subscriptions(input: ConnectionInput): Connection!
  subscriptions: [UserSubscription!]!
  interactions(readState: ReadState, input: ConnectionInput!): Connection!
}

type PreferenceSet {
  id: ID!
  user: User!
  name: String!
  active: Boolean!
  sort: sortType!
  startDate: Time
  endDate: Time
}

input PreferenceSetInput {
  name: String!
  """
  true sets the entered preference set as active, false never has any effect.
  A prefSet can only become inactive if another prefSet is set to active
  """
  activate: Boolean!
  sort: sortType!
  startDate: Time
  endDate: Time
}

enum sortType {
  chronological
  sourceName
}

type Interaction {
  id: ID!
  user: User!
  contentItem: ContentItem!
  readState: ReadState!
  percentRead: Float!
  createdAt: Time!
  updatedAt: Time!
}

enum ReadState {
  completed
  savedForLater
  partiallyRead
  unread
}

input InteractionInput {
  contentItemID: ID!
  readState: ReadState!
  percentRead: Float
}

input SrcRSSFeedInput {
  id: ID
  link: String
  feedLink: String
}

input RegisterInput {
  username: String!
  email: String!
  password: String!
  confirmPassword: String!
  firstname: String!
  lastname: String!
}

input LoginInput {
  email: String!
  password: String!
}

input GetUserInput {
  userID: ID
  email: String
  username: String
}

type Query {
  srcRSSFeed(input: SrcRSSFeedInput): SrcRSSFeed!
  sources(input: ConnectionInput): Connection!
  userFeed: UserFeed!
  me: User!
  user(input: GetUserInput): User!
  getContentItem(input: ID!): ContentItem!
  getInteractionByContentID(input: ID!): Interaction
  preferenceSets: [PreferenceSet!]!
}

type DeleteResponse {
  ok: Boolean!
}

type Mutation {
  addSrcRSSFeed(feedLink: String!): SrcRSSFeed!
  deleteSubscription(srcRSSFeedID: ID!): DeleteResponse!
  register(input: RegisterInput!): AuthResponse!
  login(input: LoginInput!): AuthResponse!
  saveInteraction(input: InteractionInput): ContentItem!
  savePreferenceSet(input: PreferenceSetInput!): PreferenceSet!
}
